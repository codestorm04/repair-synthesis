package edu.nus.mrepair.klee

import edu.nus.mrepair._
import edu.nus.mrepair.AngelicFix._
import edu.nus.mrepair.Utils._
import java.io.File
import edu.nus.mrepair.Utils.SimpleLogger._
import org.smtlib.IExpr
import scala.util.parsing.combinator._
import com.microsoft.z3._
import edu.nus.maxsmtplay._
import scala.collection.JavaConverters._

/**
  * AngelicFix implementation top class
  */

object AFRepair {

  def generatePatch(synthesisConfig: SynthesisConfig) {
    ???
  }

  def getAvailableSymbols(formula: String, solver: MaxSMT with Z3): List[String] = {
    val origClauses = solver.z3.parseSMTLIB2String(formula + "\n(check-sat)\n(exit)", Array(), Array(), Array(), Array())
    solver.solveAndGetModel(Nil, origClauses :: Nil) match {
      case Some((_, origModel)) =>
        origModel.getConstDecls().toList.map({ case d => d.getName().toString})
      case None =>
        println("UNSAT")
        Nil
    }
  }

  /**
    * Solving smt files generated by KLEE for each test case
    */
  def generateAngelicForest(smtFiles: List[String], testUniverseDir: String, testSuiteIds: List[String]): AngelicForest = {
    val af = scala.collection.mutable.Map[String, List[AngelicPath]]()

    val solver = new Sat() with Z3
    solver.init(None)

    var repairedTests: List[String] = Nil

    testSuiteIds.map({ case id => af += id -> Nil })
    smtFiles.map({
      case file =>
        println("-----------------------\nchecking path " + file)
        val formula = scala.io.Source.fromFile(file).mkString
        val afVars = getAvailableSymbols(formula, solver)
        solver.solver.reset()

        if (! afVars.isEmpty) {

          val getter = afVars.map({
            case varName =>
              s"(declare-fun aux_$varName () (_ BitVec 32)) (assert (= aux_$varName (concat (select $varName (_ bv3 32)) (concat (select $varName (_ bv2 32)) (concat (select $varName (_ bv1 32)) (select $varName (_ bv0 32)))))))"
          }).mkString(" ")

          testSuiteIds.map({
            case testId =>

              println("test case " + testId)
              val (in, out) = getTestData(testUniverseDir, testId)

              val inputAssertion = in.map({
                case (name, value) =>
                  val varName = "af_input_int_" + name
                  if(afVars.contains(varName)) {
                    s"(assert (= (_ bv$value 32) (concat (select $varName (_ bv3 32)) (concat (select $varName (_ bv2 32)) (concat (select $varName (_ bv1 32)) (select $varName (_ bv0 32)))))))"
                  } else {
                    ""
                  }
              }).mkString("\n")

              val outputAssertion = out.map({
                case (name, value) =>
                  val varName = "af_output_int_" + name
                  if(afVars.contains(varName)) {
                    s"(assert (= (_ bv$value 32) (concat (select $varName (_ bv3 32)) (concat (select $varName (_ bv2 32)) (concat (select $varName (_ bv1 32)) (select $varName (_ bv0 32)))))))"
                  } else {
                    ""
                  }
              }).mkString("\n")

              val ending = "\n(check-sat)\n(exit)"
              val clauses = solver.z3.parseSMTLIB2String(formula + inputAssertion + outputAssertion + getter + ending, Array(), Array(), Array(), Array())
              solver.solveAndGetModel(Nil, clauses :: Nil) match {
                case Some((_, model)) =>
                  repairedTests = testId :: repairedTests
                  val result = afVars.map({
                    case varName =>
                      val auxName = "aux_" + varName
                      val value = model.eval(solver.z3.mkBVConst(auxName, 32), false).asInstanceOf[BitVecNum].getInt
                      (varName, value)
                  })
                  result.map({ case (n, v) => println(n + " = " + v)})
                case None => println("UNSAT")
              }
              solver.solver.reset()
          })
        }
    })
    solver.delete()

    if (repairedTests.distinct.length == testSuiteIds.length) {
      println("REPAIRED")
    } else {
      println("FAILED")
    }

    af.toList.toMap
  }


  def getTestData(testUniverseDir: String, testId: String): (VariableValues, VariableValues) = {
    val inputsFile = testUniverseDir + File.separator + testId + ".in"
    val outputsFile = testUniverseDir + File.separator + testId + ".out"
    val inputsSource = scala.io.Source.fromFile(inputsFile)
    val outputsSource = scala.io.Source.fromFile(outputsFile)
    val inputsContent = inputsSource.mkString
    val outputsContent = outputsSource.mkString
    val in = TestMappingParser(inputsContent)
    val out = TestMappingParser(outputsContent)
    inputsSource.close()
    outputsSource.close()
    (in, out)
  }

  type VariableValues = Map[String, Int]

  object TestMappingParser extends JavaTokenParsers {
    def apply(input: String): VariableValues = parseAll(inputs, input).get.toMap
    def inputs = rep(input)
    def input = inputName ~ "=" ~ inputValue ^^ { case n ~ "=" ~ v => (n, v) }
    def inputName: Parser[String] = ident
    def inputValue: Parser[Int] = wholeNumber ^^ { case si => Integer.parseInt(si) }
  }

}
